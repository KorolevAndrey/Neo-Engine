
layout (triangles, equal_spacing, ccw) in;

uniform mat4 P, V, M;
uniform mat3 N;
uniform float time;
uniform float dampeningFactor;

uniform int numWaves;
uniform sampler2D waveData;
uniform sampler2D waveDir;

in vec3 evalPos[];
in vec4 evalTex[];

out vec4 fragWorldPos;
out vec4 fragViewPos;
out vec4 fragScreenPos;
out vec3 fragViewNormal;
out vec3 fragViewTangent;
out vec3 fragViewBinormal;
out vec4 fragTex;
out vec4 fragNormalAndHeight;

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2) {
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

vec4 interpolate4D(vec4 v0, vec4 v1, vec4 v2) {
    return vec4(gl_TessCoord.x) * v0 + vec4(gl_TessCoord.y) * v1 + vec4(gl_TessCoord.z) * v2;
}

struct WaveResult
{
    vec3 position;
    vec3 normal;
    vec3 binormal;
    vec3 tangent;
};
 
WaveResult CalculateWave(uint waveID, vec3 wavePosition, float edgeDampen)
{
    WaveResult result;

    vec4 wave = texture2D(waveData, vec2(float(waveID) / numWaves, 1));
    float amplitude = wave.r;
    float speed = wave.g;
    float steepness = wave.b;
    float waveLength = wave.a;
    vec3 direction = texture2D(waveDir, vec2(float(waveID) / numWaves, 1)).rgb;
 
    float frequency = 2.0 / waveLength;
    float phaseConstant = speed * frequency;
    float qi = steepness / (amplitude * frequency * numWaves);
    float rad = frequency * dot(direction.xz, wavePosition.xz) + time * phaseConstant;
    float sinR = sin(rad);
    float cosR = cos(rad);
 
    result.position.x = wavePosition.x + qi * amplitude * direction.x * cosR * edgeDampen;
    result.position.z = wavePosition.z + qi * amplitude * direction.z * cosR * edgeDampen;
    result.position.y = amplitude * sinR * edgeDampen;
 
    float waFactor = frequency * amplitude;
    float radN = frequency * dot(direction, result.position) + time * phaseConstant;
    float sinN = sin(radN);
    float cosN = cos(radN);
 
    result.binormal.x = 1 - (qi * direction.x * direction.x * waFactor * sinN);
    result.binormal.z = -1 * (qi * direction.x * direction.z * waFactor * sinN);
    result.binormal.y = direction.x * waFactor * cosN;
 
    result.tangent.x = -1 * (qi * direction.x * direction.z * waFactor * sinN);
    result.tangent.z = 1 - (qi * direction.z * direction.z * waFactor * sinN);
    result.tangent.y = direction.z * waFactor * cosN;
 
    result.normal.x = -1 * (direction.x * waFactor * cosN);
    result.normal.z = -1 * (direction.z * waFactor * cosN);
    result.normal.y = 1 - (qi * waFactor * sinN);
 
    result.binormal = normalize(result.binormal);
    result.tangent = normalize(result.tangent);
    result.normal = normalize(result.normal);
 
    return result;
}


void main() {
    vec4 vertPos = vec4(interpolate3D(evalPos[0], evalPos[1], evalPos[2]), 1.0);
    fragTex = interpolate4D(evalTex[0], evalTex[1], evalTex[2]);

    float dampening = 1.0 - pow(clamp(abs(fragTex.z - 0.5) / 0.5, 0.0, 1.0), dampeningFactor);
    dampening *= 1.0 - pow(clamp(abs(fragTex.w - 0.5) / 0.5, 0.0, 1.0), dampeningFactor);
 
    WaveResult finalWaveResult;
    finalWaveResult.position = vec3(0,0,0);
    finalWaveResult.normal = vec3(0,0,0);
    finalWaveResult.tangent = vec3(0,0,0);
    finalWaveResult.binormal = vec3(0,0,0);

    for(uint waveId = 0; waveId < numWaves; waveId++)
    {
        WaveResult waveResult = CalculateWave(waveId, vertPos.xyz, dampening);
        finalWaveResult.position += waveResult.position;
        finalWaveResult.normal += waveResult.normal;
        finalWaveResult.tangent += waveResult.tangent;
        finalWaveResult.binormal += waveResult.binormal;
    }
    finalWaveResult.position -= vertPos.xyz * (numWaves - 1);
    finalWaveResult.normal = normalize(finalWaveResult.normal);
    finalWaveResult.tangent = normalize(finalWaveResult.tangent);
    finalWaveResult.binormal = normalize(finalWaveResult.binormal);

    fragNormalAndHeight.w = finalWaveResult.position.y - vertPos.y;
    fragWorldPos = M * vec4(finalWaveResult.position, 1.0);
    fragViewPos = V * fragWorldPos;
    fragScreenPos = P * fragViewPos;
    fragNormalAndHeight.xyz = normalize(N * finalWaveResult.normal);
    // fragViewNormal = normalize(vec3(V * vec4(fragNormalAndHeight.xyz, 1.0)));
    // fragViewTangent = normalize(vec3(V * vec4(normalize(N * finalWaveResult.tangent), 1.0)));
    // fragViewBinormal = normalize(vec3(V * vec4(normalize(N * finalWaveResult.binormal), 1.0)));
    fragViewNormal = normalize(fragNormalAndHeight.xyz);
    fragViewTangent = normalize(N * finalWaveResult.tangent);
    fragViewBinormal = normalize(N * finalWaveResult.binormal);

    gl_Position = fragScreenPos;
}