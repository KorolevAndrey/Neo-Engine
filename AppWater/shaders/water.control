layout (vertices = 3) out;

in vec3 controlPos[];
in vec4 controlTex[];

uniform vec3 camPos;
uniform vec3 tessFactor;
uniform vec2 tessDistance;

out vec3 evalPos[];
out vec4 evalTex[];

float GetTessLevel(float Distance0, float Distance1)
{
    float AvgDistance = (Distance0 + Distance1) / 2.0;

    if (AvgDistance <= tessDistance.x) {
        return tessFactor.x;
    }
    else if (AvgDistance <= tessDistance.y) {
        return tessFactor.y;
    }
    else {
        return tessFactor.z;
    }
}

void main() {
    evalPos[gl_InvocationID] = controlPos[gl_InvocationID];
    evalTex[gl_InvocationID] = controlTex[gl_InvocationID];

    float camDist0 = distance(camPos, evalPos[0]);
    float camDist1 = distance(camPos, evalPos[1]);
    float camDist2 = distance(camPos, evalPos[2]);

    gl_TessLevelOuter[0] = GetTessLevel(camDist1, camDist2);
    gl_TessLevelOuter[1] = GetTessLevel(camDist2, camDist0);
    gl_TessLevelOuter[2] = GetTessLevel(camDist0, camDist1);
    gl_TessLevelInner[0] = gl_TessLevelOuter[2];
}