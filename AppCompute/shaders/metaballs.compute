
// byte alignment is important
struct vert {
    vec4 v;
};
layout(std430, binding = 0) buffer vertBuffer
{
	vert data[];
} vertices;

// struct normal {
//     vec3 n;
//     float buffer;
// };
// 
// struct uv {
//     float u;
//     float v;
// };
// layout(std430, binding = 1) buffer normalBuffer
// {
// 	normal data[];
// } normals;
// 
// struct element {
//     vec3 t1;
//     vec3 t2;
//     vec2 padding;
// };
// layout(std430, binding = 2) buffer uvBuffer
// {
// 	uv data[];
// } uvs;
// layout(std430, binding = 3) buffer elementBuffer
// {
// 	element data[];
// } elements;

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
	// Read the current global position for this thread
	uint storePos = gl_GlobalInvocationID.x;

	// Calculate the global number of threads (size) for this work dispatch.
	uint gSize = gl_WorkGroupSize.x * gl_NumWorkGroups.x;

	// Calculate the vertex position based on
	// the previously calculated angle and radius.
	// This is provided by the application.
    vertices.data[storePos].v = vec4(vec3(storePos / 64, storePos % 2 == 0 ? 0.0 : 2.0, 0.0), 0.0);
    // normals.data[storePos].normal = vec3(0,0,-1);
    // uvs.data[storePos].uv = vec2(0.5, 0.5);
}